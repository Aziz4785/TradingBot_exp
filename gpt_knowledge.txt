IBKR TWS API DOC : 
Welcome to this lesson on the essential components of a TWS API Python program. This includes the API classes EClient and EWrapper, a function call to create a connection to TWS, and a run loop for processing returned messages in the queue. This lesson will also include a brief discussion of the nextValidId method, and we can implement threading. Finally, we’ll walk through our reqCurrentTime method to create a basic “Hello World” style script.

To begin, in any TWS API program you’ll always see two main classes, which would be EClient and EWrapper.  EClient is used for outgoing messages which are sent from the API program to TWS or the IB Gateway.  EWrapper is used to handle incoming messages from the Interactive Brokers server through TWS or IB Gateway.

For this lesson, I will be using Visual Studio Code. However, you can use any development environment of your choice, or even just the command lines and a text editor. To begin, I will start by importing the necessary modules. I will start by importing EClient, using “from ibapi.client import *” and EWrapper, using “from ibapi.wrapper import *”.  I will also be importing the time and threading modules, which we will touch on later.

After importing my modules, I will create a class to combine the EClient and EWrapper modules. I will type “class TestApp(EClient, EWrapper):”. Next, we instantiate the class by defining our init method with def __init__(self): followed by a newline EClient init request using EClient.__init__(self,self).

After our init, let’s create the EWrapper object for NextValidId(self, orderId): to receive order Ids. This will receive the EWrapper return of next valid order id, and retain valid session throughout the trading day to prevent duplicate values. Here, I can create an object for the order id, self.orderId = orderId. Now it may be confusing, but we can now make a new function, nextId, only retaining the object. Within the function, I will increment our newly made self.orderId value by 1, and then return the self.order variable. This way we can maintain the order Id throughout future requests and return the order id to our request.

We will circle back to some of the more elaborate EWrapper functionality in a moment. However, for now, we can just print out this id by creating our TestApp reference. All this takes is setting a variable, let’s use “app”, equal to the TestApp() class. Now, we’ll connect our app to Trader Workstation, by calling app.connect(“127.0.0.1”, 7497, 0). The values in this method are the host, port, and clientId.

Assuming your TWS is on the same machine where your API code is running, this will always be “127.0.0.1” or “localhost”. We have included a description of the standard port values in the transcript of this video. You can also review your TWS socket port setting in our prior video on setting up the Trader Workstation for API use. And then our client ID can be any value, as long as another client ID connection is not using the same value.

Platform

Port

TWS Live

7496

TWS Paper

7497

IBG Live

4001

IBG Paper

4002

With our connect methodology in place, we can implement a little bit of threading to get started. The simple implementation would be to call threading.Thread(target=app.run).start().

Please be aware that we reference the object of app.run, without including the parenthesis. Next, we’ll add a quick time.sleep(1) reference, to allow our object to instantiate before we start sending requests. This value will largely depend on your internal machine speed, so you increase or decrease this value as you see fit.

Then, as a quick test to show off our nextId method, we can use a for loop as the example.  I will write the loop as for I in range(0,5): and then printing the app.nextId() method each time. If we run this script as is, we should see some notifications indicating our connection is OK, followed by our printed ids. These request IDs are used throughout our programming and need to be uniquely assigned on each request. As a result, creating this reliable incrementation tool will be essential. 

We will explore this further through future videos.

But as a simple implementation of the EClient – EWrapper duality, we can move on to a call for the current time in Trader Workstation. Within our for loop, after our call for the nextId value, I will add a new request for app.reqCurrentTime(). This begins the initial request through EWrapper, but to capture the response, we should define the currentTime function within our class.

Calling def currentTime(self,time): we can receive our time value. Within the function, we can print our time value. This function will return the current epoch time observed in Trader Workstation. Epoch time is a single integer time representing the current timestamp in milliseconds. The connection between EClient.reqCurrentTime and EWrapper.currentTime will be an ongoing theme observed through nearly all endpoints used within the API. One external request will be met with one or more asynchronous responses.

One final method to create that will be used throughout the TWS API programming will be our EWrapper.error function. Error will automatically return any error generated by the Trader Workstation while processing your request. This will include values like invalid order formats, market data issues, and more. This will not reflect code issues or similar programming logic failures.

To define this, add the new definition for error within our TestApp class, containing the arguments for self, reqId, errorCode, errorString, and advancedOrderReject. While you are welcome to simply print all of these values directly, I will be adding context to each message through an f-string so we can quickly distinguish which value refers to which argument. If we run our script now, you’ll see various “error” messages. If we read the errorString value of these messages, we’ll realize these are just notifications mentioning that various market data connections are OK. While this method will largely capture error messages, we will receive system notifications such as the market data connectivity through EWrapper.error as well.

That concludes our lesson on the Essential Components of the TWS API. Thank you for watching. If you have any questions, please be sure to review our documentation or leave a comment below this video. We look forward to having you in the next lesson of our TWS API series.

Code Snippet – essentials.py
from ibapi.client import *
from ibapi.wrapper import *
import time
import threading
class TestApp(EClient, EWrapper):
  def __init__(self):
    EClient.__init__(self, self)
  
  def nextValidId(self, orderId):
    self.orderId = orderId
  
  def nextId(self):
    self.orderId += 1
    return self.orderId
  
  def currentTime(self, time):
    print(time)
  def error(self, reqId, errorCode, errorString, advancedOrderReject=""):
    print(f"reqId: {reqId}, errorCode: {errorCode}, errorString: {errorString}, orderReject: {advancedOrderReject}")
app = TestApp()
app.connect("127.0.0.1", 7497, 0)
threading.Thread(target=app.run).start()
time.sleep(1)
# for i in range(0,5):
#   print(app.nextId())
app.reqCurrentTime()
Join The Conversation

Defining Contracts in the TWS API:

Hello, and welcome to this lesson discussing contract discovery and how to define a contract using the TWS API. Please note that our starting file content will mirror the previous video on essential API components. As a result, I would encourage viewers to review the last lesson before going further in this lesson. To explore contract definitions, we can utilize the EClient.reqContractDetails and EWrapper.contractDetails, as this provides the baseline of contract discovery before moving into other functionality like market data or order placement.

Starting out with last lesson’s template, without the currentTime references, we can start by writing out the EWrapper.contractDetails function. All we need to do is define the function, contractDetails, inside of our TestApp class. This function takes three arguments, self, reqId, and contractDetails. The first two we are familiar with, but contractDetails is a unique class, ContractDetails, which contains all of the contract’s information in a dictionary structure. Including things like the underlying contract details, the supported exchanges, and trading hours.

Users are welcome to print this value directly; however, since we’ll be printing and reading the value, we can utilize some of Python’s dictionary handling. With that in mind, I will create a variable, attrs, and set it equal to the vars() method, taking our contractDetails as an argument. This will produce the key-value pair of our contractDetails object. Then, I’ll look to print a string-joined lambda set. This will appear as print(“\n”.join(f”{name}: {value}” for name, value in attrs.items())). 

I will also add another EWrapper function, contractDetailsEnd. This function simply indicates when there is no data remaining for a request that may return several responses to a single request. The method only takes self and reqId as an argument to help with request tracking. I will use this method to announce contract details has ended, and also disconnect our API session, similar to how we did for the currentTime method before.

Stock Contracts
Now we can move on to the request side of things. Let’s keep things simple to start with and focus on requesting stock contract details, then we can build out futures or options contracts later, since those are a bit more complex. We can create a variable, such as mycontract and set it equal to a Contract object. Now, I can start establishing my contract. As a test case, maybe all I know about my trading is that I want to trade AAPL stock. Therefore, I can set mycontract.symbol to “AAPL” and then mycontract.secType = “STK”.  Please be aware that nearly all secType values are 3 or 4 character representations of a given security type. For example, we might see STK for Stocks, OPT for Options, or FUT for Futures.

We can then send out our EClient.reqContractDetails request to find information on this contract. This request only takes the arguments for a request ID, which we’ll use our app.nextId() function for, and then a Contract object, which we’ll use mycontract for. With these simple additions set, we can run our code, and we should see a large amount of data returned. That is because the contractDetails method can be used to receive any contract that approximately matches our Contract object. The best way to distinguish between your conracts is to look at the actual “contract” value returned. This will return essential values like the conid, symbol, security type, trading exchange, and listing exchange.

Before moving on, let’s take a moment to look at the overall response of the contractDetails object. I can see the extended detail of our contract object, but also values like orderTypes, which show the supported order types with the instrument,  liquidHours, time zone ID, and even market rule information. But this was not exactly what I intended to receive, so let’s further truncate this request.

I can set my contract’s currency value to USD, since I only care to trade in my own base currency. Then, I can also set my exchange value to SMART, because I want to trade using the Interactive Brokers SmartRouting feature. If we request data now, we’ll see that adding two additional parameters returns a single contract for our use and is just the contract I wanted. These four values, symbol, sectype, exchange, and currency; are the basis of any contract we’d like to use.

Users should look to include the primaryExchange value where possible. This is the item just after our trading exchange in the contract object and can be used to distinguish between multiple companies that have otherwise matching symbols and require more distinction. Adding the primary exchange can help resolve most ambiguous contracts.

Futures Contracts
With our baseline stocks settled, we can move on to Futures contracts. Before requesting our contract, I’ll adjust my EWrapper.contractDetails method to just print the contractDetails.contract value, to help conserve space, at least while we are exploring. contractDetails.contract is identical to the Contract object we are creating in our request. As a result, the parameters we send can be mirrored in the parameters we receive. We can uncomment the lambda print value once we have narrowed down our contract.

We can tweak our existing contract to another contract we’re looking for. I want to look into ES Futures trading, so I’ll adjust my contract symbol and security type to ES and FUT accordingly. For those unaware, SMART Routing is only supported for stocks, options, and combinations. As a result, I would not be able to use SMART for my ES future.

So, in this case, I will comment out the exchange field, and send my request. 

This will return numerous contracts, though we’ll notice that a lot of the contracts coming back are either CME or QBALGO. Given I don’t want to trade the algo, and I simply want to trade the CME exchange, I’ll uncomment my exchange value, and set this to “CME”. We can also find the date values, which correlate to the lastTradeDateOrContractMonth value. I will add this to my own contract month for December, and I can receive only the ES contracts traded by CME in December of 2024. If we uncomment our lambda function and run our script, we’ll find all of the relevant information we want.

Options Contract
Before diving into the options contract, I’ll once again comment out the contractDetails lambda function, and simply print the contract object. I will also tweak my existing contract object again, because now I’m thinking about trading SPX options. This will only require a few modifications from the ES contract, and would be an almost identical set of values if we were looking to trade Futures Options. I will adjust my symbol to SPX, secType to OPT, and my exchange back to SMART. If we run the script now, we’ll receive hundreds of results back, as there are several expiries, rights, and strikes traded throughout the month of December, even with our existing filtering.

To filter out our options contract further, I’ll set my right to Put, using mycontract.right = “P”. In the case of rights, you may use P or Put for puts, or C or Call for call options. With our right set, there is still a lot to filter. Near the end of our contract object, we’ll notice these “SPX” and “SPXW” values. These values are known as the TradingClass of the contract and distinguish between multiple matching derivatives. In this scenario, this distinguishes between the monthly SPX contracts and the weekly contracts. This is especially relevant, as these two contracts can overlap their expiration date, and the trading class may be the only distinct value.

If we make the request now, we will still find tons of results. This is because all of the potential strike values are being returned, which is particularly large, especially for an index like SPX. As a result, it’s best to further truncate our request by including a strike in our contract. I will narrow my focus to a strike of 5300, which gives us one last contract. I will uncomment our lambda function before running the script, so we can see all these values that were being requested and returned.

Extended Contract Information
There are several additional security types with their own unique parameters. I’d like to briefly discuss some additional resources users should consult to find these details. With regard to the API specific fields, the TWS API Contract class reference is listed in our documentation on IBKR Campus that provides context to each parameter for review.

Similarly, we also maintain an entire Contracts page, which users should consult to find which parameters are needed for each contract type. This will provide an API-Agnostic structure which displays what values, such as symbol, secType, and exchange, are required for special contract types. This will even include information on building futures spreads or option combos, all of which are built on the foundation discussed throughout this lesson.

Finally, users should look to utilize Trader Workstation’s Description page for more insight on retrieving contract-specific details. To accomplish this, search for any contract you typically consult in your day-to-day trading. After adding the contract to your watchlist, or if it is already in your Portfolio, right click the instrument, click the drop-down arrow, then “Financial Instrument Details” and finally “Description”. This will bring up a window in Trader Workstation which provides nearly all of the contract information discussed here. It is an essential tool while you are learning to search for contracts through the API independently.

This concludes our lesson on defining contracts in the TWS API. Thank you for watching. If you have any questions, please be sure to review our documentation or leave a comment below this video. We look forward to having you in the next lesson of our TWS API series.

Code Snippets – contractDiscovery.py
from ibapi.client import *
from ibapi.wrapper import *
import time
import threading
class TestApp(EClient, EWrapper):
  def __init__(self):
    EClient.__init__(self, self)
  
  def nextValidId(self, orderId):
    self.orderId = orderId
  
  def nextId(self):
    self.orderId += 1
    return self.orderId
  def error(self, reqId, errorCode, errorString, advancedOrderReject):
    print(f"reqId: {reqId}, errorCode: {errorCode}, errorString: {errorString}, orderReject: {advancedOrderReject}")
  def contractDetails(self, reqId, contractDetails):
    attrs = vars(contractDetails)
    print("\n".join(f"{name}: {value}" for name,value in attrs.items()))
    # print(contractDetails.contract)
  def contractDetailsEnd(self, reqId):
    print("End of contract details")
    self.disconnect()
app = TestApp()
app.connect("127.0.0.1", 7497, 0)
threading.Thread(target=app.run).start()
time.sleep(1)
mycontract = Contract()
# Stock
# mycontract.symbol = "AAPL"
# mycontract.secType = "STK"
# mycontract.currency = "USD"
# mycontract.exchange = "SMART"
# mycontract.primaryExchange = "NASDAQ"
# Future
# mycontract.symbol = "ES"
# mycontract.secType = "FUT"
# mycontract.currency = "USD"
# mycontract.exchange = "CME"
# mycontract.lastTradeDateOrContractMonth = 202412
# Option
mycontract.symbol = "SPX"
mycontract.secType = "OPT"
mycontract.currency = "USD"
mycontract.exchange = "SMART"
mycontract.lastTradeDateOrContractMonth = 202412
mycontract.right = "P"
mycontract.tradingClass = "SPXW"
mycontract.strike = 5300
app.reqContractDetails(app.nextId(), mycontract)


Requesting Market Data : 
Welcome to this lesson on requesting market data in the Trader Workstation API. In this video, we will be highlighting the requirements for requesting market data, how to request delayed data, how to request live market data, and how to request historical bars. Please note that these are the most popular methods of requesting market data; however, Interactive Brokers also offers tick data, histogram data, and market depth.

Discussing Market data subscriptions
Let’s begin by discussing market data subscriptions. In order for clients to subscribe to market data, users must have a funded IBKR account for at least $500 USD in most instances. There are some instances where this is not the case; however, for the average individual at Interactive Brokers, $500 is the minimum. This threshold must be maintained in addition to the cost of any subscriptions held by the account.

For those with a long-time IBKR PRO account, you may have observed that some instruments return market data to your Trader Workstation for free by default. That is because some market data can be provided to users for free while “on-platform”. On-platform simply means that users are observing data directly display through one of Interactive Brokers platforms. Exchanges consider API functionality to be considered off-platform, and as a result, typically have a cost affiliated with them. Some of the most popular market data subscriptions for API use are listed in the API Documentation for Market Data on IBKR Campus. Users can subscribe to market data through the Client Portal. 

It is also worth clarifying that Market Data is affiliated on a per-user basis. Many clients will run a single Trader Workstation instance for monitoring trades; however, it is common to have a separate machine running your trading algorithm on IB Gateway hosted on a virtual machine elsewhere. In order for both of these platforms to retrieve market data, each user consuming market data would need to subscribe to data separately.

Requesting streaming data
With the subscription discussion out of the way, we can start to dive into the actual API requests. Please note that we will be using the same framework from our Essential Components video, so if there are any questions on the initial structure in this video, please be sure to review that lesson first.

The most popular way of requesting and viewing data in the API would be with EClient.reqMktData method, which requests the same data available in the TWS Watchlists.

Requesting delayed data
Clients that do not have a market data subscription for instruments can often request 15 minute delayed data. This is only a single extra step compared to standard market data subscriptions, so I will include it before moving forward.

To clarify if your requests will be Live or delayed, users simply need to call the app.reqMarketDataType function. The only argument this takes is the type of data to retrieve, which can be 1,2,3,4 or Live, Frozen, Delayed, or Delayed Frozen respectively. Frozen data will refer to market data from the most recent close, while delayed frozen data will return yesterday’s closing values. And then as we’ve mentioned, standard delayed data will return 15-minute delayed data.

If I am subscribed to market data on a given instrument, but request delayed market data, live data will still be returned. Interactive Brokers will always try to provide the most up-to-date market data where possible.

Requesting live data
Now, let’s start building out our request for streaming data. We will be focused on requesting price and size data; however, the reqMktData request can also return string, news, generic and even Greek values depending on the tick types provided.

From within our TestApp class, let’s start defining one of our tick functions, tickPrice. This will handle all returning values related to price values. tickPrice takes self, reqId, tickType, price, and attrib as arguments. While we’re already familiar with the first two, and the last two are rather self-explanatory, the tickType argument is used to indicate what kind of data is coming in.

Each tickType is an integer value that correlates to a specific value, be it bid price, last size, closing price, or otherwise. For a full list of all of these tick values, we can look at ticktype.py inside the ibapi source files and see exactly what everything is relating to. Users are welcome to reference the returned integer values directly; however, the enumerator contains a toStr method that converts our tick type integers into the values we see before us. In our file, we can add an import for from ibapi.ticktype import TickTypeEnum. This will allow us to reference the TicKTypeEnum.toStr() method and print out our value directly in a moment.

I will print out all of these values in an ­f-string, including our reference of TickTypeEnum.toStr(). As we discussed before, this would be perfectly fine to print out our price values; however, I also want to see the quantities of our trades effected by this. To do this, we will also add the EWrapper.tickSize function to our TestApp class as well. This function only takes the arguments: self, reqId, tickType, and size.  The sizes returned here will relate to the prices returned in our tickPrice function and allow us to create a clearer picture of the trades taking place.

Now that we have everything in place to receive the data, let’s build out a contract object and a request for market data. Leaping off of our prior video, I’ll make a request for AAPL market data using the symbol, security type, currency, and exchange values.

With a contract now set, I can call app.reqMktData to start requesting my streaming data. For arguments, we’ll need to pass the reqId, which we’ll use our app.nextId() function for. I can pass mycontract for the contract object. For our next argument, the generic tick list, I will pass “232” as a string so I can retrieve the mark price from my request. For users looking to request multiple generic ticks, you would simply comma-separate the values within the string. So maybe you would pass “232, 233, 234” as an example.

The next argument defines if we are requesting a Snapshot value.

This is a single return instance aggregating the last 11 seconds of trading. If no trading has taken place, this will not return any values. And if we do see trades in the last 11 seconds, we will see those values returned in aggregate. Similarly, the next argument determines if we are requesting a regulatory snapshot. This is a snapshot used to determine the price of an instrument before executing a trade.

Regulatory snapshots will cost approximately $0.01 per request, until we reach the cost of the affiliated subscription. If I request market data for AAPL repeatedly, Interactive Brokers will eventually add the subscription to your account, as the cost of the regulatory snapshots equate to the value of the subscription anyway. The final argument takes market data options, which is an argument used only for internal purposes.

If we run this script, we’ll find an initial flood of data depicting the most recent values for several tick types, then over time we will receive all the live data prices and sizes as they come through.

Requesting Historical Data
Requesting Historical Data follows a similar pattern to the live market data requests. The one caveat to this is that market data cannot be retrieved if you do not have a valid market data subscription. Before we begin to dig into historical data, I’d like to first find how far back we can request market data. I’ll start finding this value using a new python file.

Requesting the headTimeStamp Value
In our new file, I will create a new function in the TestApp class to define the headTimeStamp function. This takes three arguments, self, a request ID, and the headTimeStamp string. Within my new function, I will print out my headTimeStamp value. I will also make a request for self.cancelHeadTimeStamp to terminate the request now that I’m done with it, and we can just pass the requestId we received as an argument. With the EWrapper piece out of the way, I will move out of the TestApp class to create my headTimeStamp request. I will copy over my same AAPL contract I used from the Live Data script, because I want to validate how far back I can find AAPL market data.

Next, I will make a call to the app.reqHeadTimeStamp function. This takes an argument for a request ID, which can use our nextId function; and a contract reference, which will take my mycontract object.  After these two, I’m now encountering something known as the “whatToShow” value. This same value is used to denote what data is displayed in your TWS bar charts. In my case, I will use the value for Trades, though the full list of whatToShow values are available in our documentation.

The next argument relates to using regular trading hours. A 1 will indicate that we want the earliest date within trading hours, while a 0 will request the earliest date outside of trading hours. Finally, we have the formatDate parameter. This will indicate whether we want 1, a UTC timestamp in a string format, or 2, an Epoch timestamp. The latter is an integer representation of the same timestamp. You can consider the former better for human consumption, while the latter is best utilized in a programmatic request structure. I will show these off in just a moment by making two requests.

If we run this script using ‘1’ as the date format, we’ll see 19801212-14:30:00. Meaning AAPL’s “Trades” market data can go as far back as December 12, 1980 at 9:30 AM Eastern. Before we move on, I’ll quickly add another print statement to my headTimeStamp method for the datetime.datetime.fromtimestamp function, taking in the integer version of our headTimeStamp. If I change my original request to use 2 as my date format, I’ll print out the original epoch value as well as the python translated datetime, which is automatically converted to my pc’s local time in US/Central time.

Requesting historical bars
Now that we know our historical data range, we can start making a request for historical data. You are welcome to use the same file, but for my demonstration, I’ll be starting from a fresh example of our standard layout but add in our AAPL contract again. As always, we’ll define the EWrapper function inside TestApp using def historicalData. This function takes an argument for self, reqId, and bar. We will finish the function by printing the reqId and bar values.

I will note that we are printing out the full bar object; however, the bar object can be split out, so you may print bar.open for the opening price, bar.close for the closing price, and so on. But just for our presentation here, I’ll print the whole thing.

Each bar size is returned separately, so for us to know we’re done we should reference the EWrapper function for historicalDataEnd. This function takes an argument for self and reqID and is just meant to indicate that all available data has been returned to the user.

With the wrapper functions set, we’ll start our EClient request. To make the request, we’ll call the app.reqHistoricalData function. This takes 10 total arguments, starting with reqid, contract.

The next argument is endDateTime, which takes the value we’d like to end our historical data at. If we leave this as an empty string, the system will assume the current time. Otherwise, we would make a format for year, month, day followed by the 24 hour timestamp, and a timezone. You must pass the timezone for the exchange, available through a Contract Details request, the exact timezone used for your TWS, which is set prior to the homescreen, or using UTC. I will send my request for “20240523 16:00:00 US/Eastern”.

Then, we’ll pass in a duration value, which corresponds to the full interval over which data will be returned. So, if I specify “1 D”, I will receive however many bars in a single day. On the topic of bars, the next argument will take the bar size. In my case, I can pass “1 hour” to receive an hour.

This means I will receive 7 bars for my day, a bit more on that later.

Moving forward in our arguments, we’ll find more familiar values, like the whatToShow value we used before, which I’ll use “TRADES” for once again, then useRth and formatDate, again using 1 in both cases. Now we have the option for “keepUpToDate”, which allows us to build bars as data is available and return these new bars to the historicalDataUpdate function. I’m not interested in this data at the moment, so I’ll go ahead and leave this as False for now. Finally, we end with market data options, which I’ll again leave as an empty list.

Now if we run this script, I will see my request ID, and all of my bar’s values. While most of this is self-explanatory, there are a few points I’d like to mention from the programmatic standpoint. You might notice that we sent the request using US/Eastern, but my data shows America/Chicago. That’s because I’m choosing to print out my “Operator Timezone” even though I made the request with the “Instrument Timezone”. You can modify the time zone returned in TWS by opening the Global Configuration page and opening the API Settings. You’ll notice a section for “Send instrument-specific attributes for dual-mode API Client in”. Specifying Operator Timezone returns your TWS time zone, Instrument time zone returns the time zone for the contract, and UTC is obviously the UTC time zone.

The other piece I’d like to mention is the 7 bars I had referenced earlier. The Date value in the bar references the starting time for the bar. In my case, we can see my bar started at 08:30:00 America/Chicago, which is when NASDAQ opens for trading AAPL. But then we’ll see 09:00 as our next bar, meaning our first bar is only 30 minutes long, before turning into a series of 1-hour bars. This is the same behavior as Trader Workstation, though it may not be as commonly understood when pulling data programmatically. Therefore, it’s best practice to use the next bar as an indicator of approximate bar size.

This concludes our lesson on market data in the TWS API. Thank you for watching. If you have any questions, please be sure to review our documentation or leave a comment below this video. We look forward to having you in the next lesson of our TWS API series.

Code Snippet – headTimeStamp
from ibapi.client import *
from ibapi.wrapper import *
import datetime
import time
import threading
port = 7497
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: OrderId):
        self.orderId = orderId
    
    def nextId(self):
        self.orderId += 1
        return self.orderId
    
    def error(self, reqId, errorCode, errorString, advancedOrderReject=""):
        print(f"reqId: {reqId}, errorCode: {errorCode}, errorString: {errorString}, orderReject: {advancedOrderReject}")
    
    def headTimestamp(self, reqId, headTimeStamp):
        print(headTimeStamp)
        print(datetime.datetime.fromtimestamp(int(headTimeStamp)))
        self.cancelHeadTimeStamp(reqId)
app = TestApp()
app.connect("127.0.0.1", port, 0)
threading.Thread(target=app.run).start()
time.sleep(1)
mycontract = Contract()
mycontract.symbol = "AAPL"
mycontract.secType = "STK"
mycontract.exchange = "SMART"
mycontract.currency = "USD"
app.reqHeadTimeStamp(app.nextId(), mycontract, "TRADES", 1, 2)
Code Snippet – historical_market_data.py
from ibapi.client import *
from ibapi.wrapper import *
import datetime
import time
import threading
port = 7497
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: OrderId):
        self.orderId = orderId
    
    def nextId(self):
        self.orderId += 1
        return self.orderId
    
    def error(self, reqId, errorCode, errorString, advancedOrderReject=""):
        print(f"reqId: {reqId}, errorCode: {errorCode}, errorString: {errorString}, orderReject: {advancedOrderReject}")
    
    def historicalData(self, reqId, bar):
        print(reqId, bar)
    
    def historicalDataEnd(self, reqId, start, end):
        print(f"Historical Data Ended for {reqId}. Started at {start}, ending at {end}")
        self.cancelHistoricalData(reqId)
app = TestApp()
app.connect("127.0.0.1", port, 0)
threading.Thread(target=app.run).start()
time.sleep(1)
mycontract = Contract()
mycontract.symbol = "AAPL"
mycontract.secType = "STK"
mycontract.exchange = "SMART"
mycontract.currency = "USD"
app.reqHistoricalData(app.nextId(), mycontract, "20240523 16:00:00 US/Eastern", "1 D", "1 hour", "TRADES", 1, 1, False, [])
Code Snippet – LiveData.py
from ibapi.client import *
from ibapi.wrapper import *
import datetime
import time
import threading
from ibapi.ticktype import TickTypeEnum
port = 7497
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: OrderId):
        self.orderId = orderId
    
    def nextId(self):
        self.orderId += 1
        return self.orderId
    
    def error(self, reqId, errorCode, errorString, advancedOrderReject=""):
        print(f"reqId: {reqId}, errorCode: {errorCode}, errorString: {errorString}, orderReject: {advancedOrderReject}")
      
    def tickPrice(self, reqId, tickType, price, attrib):
        print(f"reqId: {reqId}, tickType: {TickTypeEnum.toStr(tickType)}, price: {price}, attrib: {attrib}")
      
    def tickSize(self, reqId, tickType, size):
        print(f"reqId: {reqId}, tickType: {TickTypeEnum.toStr(tickType)}, size: {size}")
app = TestApp()
app.connect("127.0.0.1", port, 0)
threading.Thread(target=app.run).start()
time.sleep(1)
mycontract = Contract()
mycontract.symbol = "AAPL"
mycontract.secType = "STK"
mycontract.exchange = "SMART"
mycontract.currency = "USD"
app.reqMarketDataType(3)
app.reqMktData(app.nextId(), mycontract, "232", False, False, [])

Placing Orders using TWS Python API:
A common reason to use the Trader Workstation API is to place an order to an Interactive Brokers’ account from a third party or custom software. This might be part of an automated strategy or caused by a manual user interaction in an API client’s graphical user interface.

In this lesson we will discuss the placeOrder function in the API EClient class, describe how it is used for order placement, as well as describing those functions which were used to monitor order stats and execution information.

Essentially, any order type which we place from TWS can also be placed from the API. This includes advanced order types such as IB Algos, bracket orders and conditional orders. Most order attributes from TWS can also be used with the TWS API. In general, order attributes must be set from the API by defining different fields within the API order class when an order is sent. However, there are also some attributes which will be read from the presets in the session of TWS or the IB Gateway to which the API client is connected.

Interactive Brokers offers an array of orders and attributes and provides access to more than 100 exchanges worldwide. This leads to numerable combinations of order types, instruments and exchanges. The best tool to use and check if a particular combination of order type, instrument and attribute is valid is in TWS itself.

Before creating a particularly complex order from the API, it is always recommended to first check if the same order can be created in TWS Then, if the combination isn’t valid, this will be indicated by TWS because either the order type will be greyed out or not displayed for the combination.

For a simple demonstration of invoking the placeOrder function and receiving the associated callbacks for monitoring orders, we will show how to place an order in the paper account for AAPL stock using a simple program.

Before placing any order to a live account, it is recommended to first place the order in the paper account to verify your order is being placed as intended.

Paper accounts are offered to all Interactive Brokers account holders and demo accounts can be accessed even before a live account is opened.  

Here, I’ve created a file called placeOrder.py which demonstrates how to place the AAPL order through the API.

In this file, we will create the test class which drives from both EClient and EWrapper. But instead of overriding the functions as we did previously, we will override functions related in EWrapper for placing and monitoring orders. Namely nextValidId, orderStatus, openOrder and execDetails or execution details.

The callback nextValidID located at the top is used to receive the next valid order ID for the API client to place a new order.

The next valid ID callback is invoked in response to the API client either by calling the function’s reqIds in the EClient class or invoked after the initial connection is completed.

For this lesson, we will continue using AAPL as our contract. And while I could type out my contract object and put it directly into my order request later, this example can show off some benefit of using a combined class for EClient and EWrapper. I can use my returned contractDetails variable from EWrapper.contractDetails, and specify “contractdetails.contract” to use the contract object directly.

We will start the lesson by placing a simple market order. To get started, I will need to start a process similar to our contracts by creating an order object. I will call this “myorder”. Next, we will need to cover a few attributes that will always need to be included in our orders. I will start with myorder.orderId and set this equal to the orderId variable from the nextValidId method.

Next, I will dictate my action, using myorder.action. In this case, I will set the value to BUY, though you may enter SELL here if that is preferred. Then, I will include my order type, and set this equal to “MKT” for market order.

And then we will end by specifying my quantity. To do so, we will enter myorder.totalQuantity and set this equal to 10. And those are all the required values to place a simple order. We will discuss additional flags later, but this is simply the minimum.

Now that we have our contract object, and our order object, we are ready to move on to our order placement. Here we can make a request to EClient’s placeOrder method. To do so, I will type self.placeOrder. Then in parentheses, I will reuse my orderId as my requestId, then I will specify my contract object, then my order object.

That is all that is needed to place an order. Unlike requesting market data or contract details, we technically do not require that any EWrapper method be called. I can look in Trader Workstation and see that this order has been placed.

However, I think we may want to see details on our orders returned to us after we submit them. Let’s first create a limit order to better showcase these fields.

I will keep most of my order object the same as before, with a few key exceptions. First, I will change my action to “SELL” instead of “BUY”.

After that I will move on to Time in Force, or TIF. I will be using “GTC”, though this field has the same options as TWS, such as MOC for market on close. I would note that if no TIF is specified, it will use DAY order by default.

Then, I can change my order type to LMT instead of MKT.

And finally, I will use myorder.lmtPrice to specify my limit value. For AAPL, I will specify 144.80

As we could see from our contract details request, all contracts have a minimum tick value. For AAPL stock, for instance, this is one cent min tick, so orders can’t have prices specified with more than two decimal places or less than one cent. There is more information about finding the minimum increment for different instruments in the API reference guide.

Now that we have the order ID, the contract object and the order object, we can invoke place order. After TWS receives a valid order, it will begin sending back messages to the callback functions, order status, open order and execution details to indicate an order status as well as any changes in the order status, which occur.

Open Orders
The openOrder method will show us details whenever an order is placed. We will see the full order and contract details of a given order after it has been placed. For instance, in this case we would expect to see an AAPL limit order there with a time in force of GTC and an order price of 144.80 USD.

It is important to note that openOrder also returns the orderState object. orderState will include values such as commission, initial margin, and maintenance margin. Just like we did with contractDetails before, we can review the order_state.py file in the source code to see what other flags can be requested specifically.

Now, in addition to the openOrder function, we will also want to include the orderStatus method. While openOrder provides information on an order once it is placed, orderStatus provides information on the order thereafter. After every submission of an order, as soon as the order is valid usually you would see an order status callback which would be either pre-submitted, submitted or filled. Sometimes there will be duplicates which might need to be filtered out by the API client.

Order Executions
If the order executes there will always be execDetails or execution details for every partial fill. This can be thought of as the summary of the order. We can review the orderId, the executionId, information on the contract, information on the average price, and so on.

So, if there is more than one fill for a particular order you would see multiple callbacks for exec details. The callback would have information such as the order ID, which would be different than the API order ID. This is an order ID which is unique in the account and generated by TWS.

You would see the number of shares which have executed. You would also see a last liquidity flag which would tell us if this execution either added or removed liquidity from the market.

I will go ahead and run the script and that should immediately place the order for AAPL stock. A sell order for ten shares at the limit price of 144.00.

When we scroll down to the bottom, we can see that we receive an immediate execution. That’s because the current price of AAPL is at about 144.75 and this is during market hours, so the order immediately became active.

Before that occurred, the callback we received was open order. Open order callback let us know the details of the order.

The next orderStatus we receive will be a filled status because the order filled pretty much immediately, at least in the paper trading simulation engine and that tells us how many shares filled, how many are remaining, and also the fill price.

We also received execution details more or less simultaneously with that order status so there’s information like the exact execution details ID as well as the same information about the number of shares which filled and the filled price.

Modify Orders

Now let’s say we want to modify an order. Because we included the EWrapper callbacks for our order, we can receive our order ID, and easily modify this order whenever we need. We can simply return to our order object with our problematic orderId, change our orderId from nextValidId’s orderId, and use it here. Now, any changes applied to this order submission will modify our original order.

While I may be using a very simple example here with very human error, I would like to emphasize that this process can all be done programmatically for on-the-fly adjustments to your orders to coincide with the market, or other more complex examples.

Let’s go ahead and walk through this process. Let’s say I placed an order for $1490.00 instead of my $149.00 example. Just a simple typo with very big repercussions all because I missed the decimal place. Because I have the orderId from that request in my callback from before, I can modify this order. I can change my order to use orderId 15 again, then put in the correct price. Now, if I go ahead and put $149.00 in my limit price value and then resubmit the order, I can run my code again, and we can see that this order updated. And if you had any doubts, we can return to Trader Workstation and see that this order has updated there as well.

These are just some order types that Interactive Brokers offers through the Trader Workstation, and you are welcome to explore our wide array of available offerings notated in our documentation.

This concludes our video on Basic Orders and Order Modification in the TWS API. Thank you for watching, and we look forward to having you join us for more TWS Python API lessons.

TWS API Online Documentation

Available Order Types & Algos using TWS API

Retrieving current active Orders

Order Management

Minimum Price Increment

Checking Margin Changes

Order Efficiency Ratio (OER)

from ibapi.client import *
from ibapi.wrapper import *
class TestApp(EClient, EWrapper):
  def __init__(self):
    EClient.__init__(self, self)
  def nextValidId(self, orderId: OrderId):
    mycontract = Contract()
    mycontract.symbol = "AAPL"
    mycontract.secType = "STK"    
    mycontract.exchange = "SMART"
    mycontract.currency = "USD"
    self.reqContractDetails(orderId, mycontract)
  def contractDetails(self, reqId: int, contractDetails: ContractDetails):
    print(contractDetails.contract)
    myorder = Order()
    myorder.orderId = reqId
    myorder.action = "SELL"
    myorder.tif = "GTC"
    myorder.orderType = "LMT"
    myorder.lmtPrice = 144.80
    myorder.totalQuantity = 10
    self.placeOrder(myorder.orderId, contractDetails.contract, myorder)
  def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
    print(f"openOrder. orderId: {orderId}, contract: {contract}, order: {order}")
  def orderStatus(self, orderId: OrderId, status: str, filled: Decimal, remaining: Decimal, avgFillPrice: float, permId: int, parentId: int, lastFillPrice: float, clientId: int, whyHeld: str, mktCapPrice: float):
    print(f"orderId: {orderId}, status: {status}, filled: {filled}, remaining: {remaining}, avgFillPrice: {avgFillPrice}, permId: {permId}, parentId: {parentId}, lastFillPrice: {lastFillPrice}, clientId: {clientId}, whyHeld: {whyHeld}, mktCapPrice: {mktCapPrice}")
  def execDetails(self, reqId: int, contract: Contract, execution: Execution):
    print(f"reqId: {reqId}, contract: {contract}, execution: {execution}")
app = TestApp()
app.connect("127.0.0.1", 7497, 100)
app.run()


TWS Python API Placing Complex Orders:
In this lesson, we will cover information about placing complex orders.

Before we begin, we will need to add some new imports compared to our usual two. First, be sure to include “from ibapi.tag_value import TagValue”. Then, be sure to add “from ibapi.contract import ComboLeg”.

Let’s begin by placing some more complex orders. Let’s start by making a Stock Combo, though this same process could be used for Futures or Options Spreads, with different contract details. In this case, I want to simultaneous buy TSLA and sell AAPL as a stock combo.

While moving through this lesson, please keep an open mind as to what Buy/Sell and Long/Short mean with respect to combos.

For example, when I enter a short position I need to sell a stock when I have a position of 0.

Some traders can be confused by selling shares to enter a position, and “buying” shares can be used to close a position.
This logic can doubly apply to combo orders. This is because I can BUY a combo, which will leave me short in a position, or I can SELL a combo, which could make me long in that position.
To further explain this, let’s start with a brief example. Let’s assume I want to be Long for the total trade. Right now, TSLA currently has a higher share price than AAPL, so I will use that as my base value.

So, if I want to be long for the whole combo, I can enter the trade by either:

Buy the combo, using a positive ratio on TSLA, and a negative ratio on AAPL.
OR

Sell the combo, using a negative ratio on TSLA, and a positive ratio on AAPL.
This structure is just like a vector-scalar multiplication:

You can think of buy as a positive one and sell as a negative one.

So, in this matrix you can see that I am trying to buy the whole of the share, and therefore, TSLA as a buy order times the whole of the buy order for the combo will net me a positive TSLA position. Similarly, if I buy the SELL of an AAPL position, I will wholly be negative on that.

We can invert this, and I can then do a sell order for the full combo. If I am selling the TSLA order and selling the whole of the combo, in reality, that is a negative one times a negative one, which brings me to a positive one, or a buy in this example.

Similarly, a negative one, or a sell for the combo times a positive one, or a buy for the AAPL shares, will then give me an overall position of negative or shorting the APPL stock.

Combo Order

To start, let’s take a look at our contract. We will be introducing a new concept here. As usual, I will have my contract object, mycontract. For the example, I will include both of my underlyings. In the stock combo example, I will be using AAPL,TSLA; however, for a future or option spread, you will just use your one underlying value, such as ES or SPX respectively. Now, for the secType, I will use BAG. This indicates that I am using a combo order to the system. Exchange and Currency will remain the same as usual.

Now I can begin to add legs to my order. I will create my first leg. To do so, I will create leg1 and set it equal to ComboLeg().

Then I will add my leg’s contract ID, in this case I will use TSLA, 76792991. I will be using a ratio of 1; however, you are welcome to change this value to a higher number as needed. I’ll add my leg’s action, or BUY per my ratio before, and then set my leg’s exchange as SMART.

Then, I can edit my second leg, which I will call leg2. Just like before, I will add AAPL’s conid, another ratio of 1, and exchange of SMART. However, this time I will set my action to SELL.

Now that we have our legs, we can attach them to our contract object. To do this, I will type “mycontract.comboLegs = []”.

Then I can append each leg to my list, “mycontract.comboLegs.append(leg1)”, “mycontract.comboLegs.append(leg2)”.

Keep in mind, I am only doing a 2-leg stock combo. Just like in TWS, I could have up to six legs on a guaranteed spread.

This is everything we need for our contract. Let’s get started with our order object. We have our usual options of a Market or Limit Order; but there are alternative order types such as REL+MKT that we would recommend investigating further in our documentation’s Order section. In this case, I will use a LMT order.

As I mentioned before, TSLA is at about $225 and AAPL is about $150. If we do the math, we know our order would put us at a current price of about $75. I will set my limit price to $80.

Our other order attributes will be the same, except in my case I will be adding myorder.smartComboRoutingParams as an empty list. These are for unique values for combo orders. In particular, because I am using a Non-guaranteed order, I will need to approve this for the system. To do so, I will append to that list, “TagValue(‘NonGuaranteed’, ‘1’)” to approve the use of non-guaranteed orders.

With that set, I can now submit my order. If we look at the order in TWS, we will see this order pair reflected appropriately.

Before moving on, I would like to note that this combo order structure is the same structure used for Bear Call/Bull Put orders, Iron Condors, and more. Please reference our documentation for further information.

Bracket Order

With the Combo order complete, I would like to now build out a bracket order. For bracket orders, we can use a different approach than what was used for combos. Here, I will only be making a profit-taker and stop-loss bracket order for an AAPL stock order. This will start as a standard Limit order just like in our prior videos. I will add my action here as a BUY, though instead of my usual “myorder” name, I will call this “parent”. I will also add “parent.transmit = False” so we do not prematurely submit and/or execute a trade.

Now I have my parent order, but I need to go ahead and build my profit taker initially. To do so, I will create my order object, profit_taker. Now I’ll set my order ID to my parentId + 1, and then my parent ID accordingly. I’ll set my action to SELL, another orderType of LMT, and a limit price. Once again, I’ll leave my profit_taker.transmit = False.

And now making this one last order, this time for stop loss. Like before, I will set my stop_loss as my order object name. Then I can deem my stop_loss action as a SELL.

Now I can set my orderType to “STP” in my stop loss, and then set my stop_loss.auxPrice for the stop price. In this instance, I will change my stop_loss.transmit value to TRUE now that I have all of my orders.

Now we can place all of these orders. As usual, I can use my self.placeOrder() request to start placing my orders. I will go ahead and place my order for my parent order, with my parent orderId, mycontract, and then the parent object.

We will then do the same for my profit_taker, with its respective values, and then finally we can end with our stop_loss. I would note that we have to use the parent first, as the other two pieces of the order build off the parent order ID.

Conversely, we must end with the stop loss in this scenario as this contains the final order transmission from that transmit.true or transmit=false.

If we run our code, we can see in Trader Workstation our bracket order posted in our orders summary. We will be able to see these values in our openOrder or orderStatus callbacks.

Bracket orders use the same structure as Hedging orders, and OCA orders. We would advise reviewing our documentation further if you are interested in using these order types.

Order Management

It is important to bear in mind the order efficiency ratio which tracks the ratio of messages sent or submissions, modifications, and cancellations, to the number of orders which actually execute. In general, this ratio is expected to be around 20 or less and is automatically tracked by the Interactive Brokers servers. Please review our IBKRinfo articles describing this topic for more information as well as the calculations to find these values.

This concludes our video on Complex Orders in the TWS API. Thank you for watching, and we look forward to having you join us for more TWS Python API lessons.
Code Snippet: Bracket Order 

 
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.contract import ComboLeg
from ibapi.tag_value import TagValue
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: int):
        # Order info
        mycontract = Contract()
        mycontract.symbol = "AAPL"
        mycontract.secType = "STK"
        mycontract.exchange = "SMART"
        mycontract.currency = "USD"
        parent = Order()
        parent.orderId = orderId
        parent.orderType = "LMT"
        parent.lmtPrice = 140
        parent.action = "BUY"
        parent.totalQuantity = 10
        parent.transmit = False
        profit_taker = Order()
        profit_taker.orderId = parent.orderId + 1
        profit_taker.parentId = parent.orderId
        profit_taker.action = "SELL"
        profit_taker.orderType = "LMT"
        profit_taker.lmtPrice = 137
        profit_taker.totalQuantity = 10
        profit_taker.transmit = False
        stop_loss = Order()
        stop_loss.orderId = parent.orderId + 2
        stop_loss.parentId = parent.orderId
        stop_loss.orderType = "STP"
        stop_loss.auxPrice = 155
        stop_loss.action = "SELL"
        stop_loss.totalQuantity = 10
        stop_loss.transmit = True
        self.placeOrder(parent.orderId, mycontract, parent)
        self.placeOrder(profit_taker.orderId, mycontract, profit_taker)
        self.placeOrder(stop_loss.orderId, mycontract, stop_loss)
    def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
        print(f"openOrder: {orderId}, contract: {contract}, order: {order}, Maintenance Margin: {orderState.maintMarginChange}")
    def orderStatus(self, orderId: OrderId, status: str, filled: float, remaining: float, avgFillPrice: float, permId: int, parentId: int, lastFillPrice: float, clientId: int, whyHeld: str, mktCapPrice: float):
        print(f"orderStatus. orderId: {orderId}, status:  {status}, filled: {filled}, remaining: {remaining}, avgFillPrice: {avgFillPrice}, permId: {permId}, parentId: {parentId}, lastFillPrice: {lastFillPrice}, clientId: {clientId}, whyHeld: {whyHeld}, mktCapPrice: {mktCapPrice}")
    def execDetails(self, reqId: int, contract: Contract, execution: Execution):
        print(f"execDetails. reqId: {reqId}, contract: {contract}, execution:  {execution}")
app = TestApp()
app.connect("127.0.0.1", 7497, 1000)
app.run()
Combo Order Snippet

from ibapi.client import *
from ibapi.wrapper import *
from ibapi.contract import ComboLeg
from ibapi.tag_value import TagValue
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: int):
        # Order info
        mycontract = Contract()
        mycontract.symbol = "AAPL,TSLA"
        mycontract.secType = "BAG"
        mycontract.exchange = "SMART"
        mycontract.currency = "USD"
        leg1 = ComboLeg()
        leg1.conId = 76792991
        leg1.ratio = 1
        leg1.action = "BUY"
        leg1.exchange = "SMART"
        leg2 = ComboLeg()
        leg2.conId = 265598
        leg2.ratio = 1
        leg2.action = "SELL"
        leg2.exchange = "SMART"
        mycontract.comboLegs = []
        mycontract.comboLegs.append(leg1)
        mycontract.comboLegs.append(leg2)
        myorder = Order()
        myorder.orderId = orderId
        myorder.action = "BUY"
        myorder.orderType = "LMT"
        myorder.lmtPrice = 80
        myorder.totalQuantity = 10
        myorder.tif = "GTC"
        myorder.smartComboRoutingParams = []
        myorder.smartComboRoutingParams.append(TagValue('NonGuaranteed', '1'))
        self.placeOrder(orderId, mycontract, myorder)
    def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
        print(f"orderId: {orderId}, contract: {contract}, order: {order}, Maintenance Margin: {orderState.maintMarginChange}")
    def orderStatus(self, orderId: OrderId, status: str, filled: float, remaining: float, avgFillPrice: float, permId: int, parentId: int, lastFillPrice: float, clientId: int, whyHeld: str, mktCapPrice: float):
        print(f"orderStatus. orderId: {orderId}, status:  {status}, filled: {filled}, remaining: {remaining}, avgFillPrice: {avgFillPrice}, permId: {permId}, parentId: {parentId}, lastFillPrice: {lastFillPrice}, clientId: {clientId}, whyHeld: {whyHeld}, mktCapPrice: {mktCapPrice}")
    def execDetails(self, reqId: int, contract: Contract, execution: Execution):
        print(f"execDetails. reqId: {reqId}, contract: {contract}, execution:  {execution}")
app = TestApp()
app.connect("127.0.0.1", 7497, 1000)
app.run()

Accessing Portfolio Data and Account Information:
Welcome to our lesson on retrieving real-time portfolio and account information.

Before we begin it is important to note that historical portfolio information is not available by design since TWS is a trading application. Therefore, it is not available to the API.

There are several different functions in the API which would be used to subscribe to the position updates, each follow the same subscribe and publish model where the initial subscription request is made. Then TWS will send back a complete list of all positions matching the query. Afterwards e-wrapper will continue to send back updates to the list as they occur in real time until the subscription is canceled.

The first function is ReqAccountUpdates.

This function causes both position and account information to be returned for a specified account. It can only be used with a single account at a time. This means it’s most commonly used in single account structures. If you have a multiple account structure, such as an advisor account or a linked account, more commonly a different function will be used.

A second function which can be used to query position information is just called ReqPositions.

This is used to subscribe to position updates for up to 50 sub-accounts simultaneously. If you have an advisor account with multiple sub-accounts or an introducing broker account with multiple sub-accounts this would be the function commonly used.

It’s important to keep in mind if there’s a very large number of sub-accounts, you’d likely need to use a different function such as ReqPositionsMulti, which subscribes to position updates and the single sub-account and/or model portfolio.

It is commonly used in the case, where there are many sub-accounts and the function ReqPositions can’t be used to receive position updates for all these accounts in real-time. Or in case you’re interested in the positions in a particular model portfolio, which are sometimes enabled on request, in financial advisor or introducing broker accounts.

It’s important to keep in mind that these functions will only return information about current positions in the account. They cannot return information about historical positions. If you’re interested in receiving information about positions in your account from yesterday or last week, this can be obtained through flex queries or statements in Account Management. It’s even possible to obtain programmatic access to flex queries using the Flexweb service.

Another common point of confusion is with cash balances.

So virtual cash positions which don’t represent real cash balances but are only bookmarks used by forex traders to track trades, are returned with position information, and are represented by a Forex pair, for instance EUR.USD. However, real cash balances are returned with the account information discussed next and always listed as a single currency and not as a pair.

For instance, you might see a cash balance of $20,000 USD but if you see a pair such as EUR.USD that doesn’t represent the real cash balance, but a virtual position. Account information such as a net liquidity in the account, cash balances and different currencies, along with the required margin amounts are returned after calling several different functions.

The first function which is commonly used, which we discussed earlier is ReqAccountUpdates.

This returns information about both positions and account data in a single account. Or in the case of financial advisor accounts, you can access aggregated data from all sub-accounts.

However, it can’t be used to subscribe to updates from multiple sub-accounts simultaneously.

The second function is reqAccountSummary, which is more commonly used to subscribe to account updates from multiple accounts at once.

Finally, there is also the function reqAccountSummaryMulti, which is used to subscribe to account updates from a single sub-account at a time in the case where there are more than 50 sub-accounts and can also use with portfolio models.

When requesting account data from the API, a complete list of all types of data or account keys is initially returned and then updates are sent either if there is a trade or if the account value has changed within the 3-minute period. This corresponds to the same update pattern, which you can expect in the TWS account window.

Here is a short sample program using ReqAccountUpdates.

Notice it looks very similar to the previous programs. The only difference is the function we call here in the start function, ReqAccountUpdates, and then the callback functions we’ve overridden. The overridden functions handle return data or update portfolio, update account value, update account in time and account download end.

After we invoke ReqAccountUpdates for a particular account in this case, the account number can be omitted because it’s connected to an active TWS session.

If you want to start a subscription, you invoke ReqAccountUpdates with true. If you want to cancel it or stop it you can call ReqAccountUpdates with false, which is what I’ll do in the stop function.

After I call ReqAccountUpdates. I set the subscription to true for this account, then updates are sent first back to update account value that has different information. This can return the cash balance, the required margin for the account, or the net liquidity and so on.

Then after that data is returned, and there will be a separate callback for every key to update account value. Then we will also receive portfolio information back to the callback function update portfolio. The callback update portfolio will be one for each position in the account. You can see the different types of information returned along with the position.

See unrealized P&L, which will be the total unrealized P&L since the position was open, the realized P&L which would be the realized profit loss for the current day.  If you’ve closed out any positions, as well as the account name, the current market value, the average cost used to open the position and of course the position size.

And then with each callback, there is some time to let the data run completely, there will be an account download end to let you know that all information has been returned.

This functionality is only called after the first full batch of information is returned and then after that you will receive updates in real-time but updated download end won’t be called because there won’t be a complete batch of information. It will only be those positions or those account values which have changed since the last return of data.

Since I’m already logged in the TWS, and listening on socket port 7497, I can just run this program and it should connect and then call ReqAccountUpdates, wait five seconds and the. print out all the results and then call the stop function.

Let’s take a look at the results.

So, you can see the initial notifications returned in the error callback to let us know the market data farm is okay. Then we will receive all the different account values in alphabetical order starting with the account code, which is just the account number, it’ll give us information like say accrued cash, dividend information, which is just dividends accrued in the account, the cash balances on the different currencies so you can see these are the real cash balances showing the different currencies.

For instance, my cash balance indicates that I have 0 euros, I can also see I have $271,668.68 US dollars in cash. And then we receive other information including margin information, leverage in the account, realized P&L for the account.

And then after all the account keys return, we’ll receive the portfolio information.

These are the current positions in the account, so you can see for instance there’s a position in Apple Inc, AAPL a position of 1000 which has a current market value of $148k and an average cost of $140.00, the total unrealized P&L is ~$7,200.00 and the realized P&L is 0.0 meaning I have not traded this position today. Then we receive a separate call back for every position in the account with that information as well as a time of when that information is current.

If we were just to leave this program, instead of calling the stop method, then make a trade in TWS, if a position was changed then we immediately received that call back to let us know there’s a change in position. Though we would only see changes for that particular instrument, and we would not see changes for any other instrument.

Finally, here at the end of the first complete batch of information we received account download end just to let us know that all information has been returned. So that’s our lesson for today on receiving portfolio and account information.   Thank you for watching and we look forward to our next lesson.

TWS API Online User Guide

Account and Portfolio Data – API User Guide

Account Updates
from ibapi.client import EClient
from ibapi.wrapper import EWrapper
from ibapi.contract import Contract
from threading import Timer
class TestApp(EWrapper, EClient):
    def __init__(self):
        EClient.__init__(self, self)
    def error(self, reqId, errorCode, errorString, advancedOrderReject=""):
        print("Error: ", reqId, " ", errorCode, " ", errorString)
    def nextValidId(self, orderId):
        self.start()
    def updatePortfolio(self, contract: Contract, position: float, marketPrice: float, marketValue: float,
                        averageCost: float, unrealizedPNL: float, realizedPNL: float, accountName: str):
        print("UpdatePortfolio.", "Symbol:", contract.symbol, "SecType:", contract.secType, "Exchange:", contract.exchange,
              "Position:", position, "MarketPrice:", marketPrice, "MarketValue:", marketValue, "AverageCost:", averageCost,
              "UnrealizedPNL:", unrealizedPNL, "RealizedPNL:", realizedPNL, "AccountName:", accountName)
    def updateAccountValue(self, key: str, val: str, currency: str, accountName: str):
        print("UpdateAccountValue. Key:", key, "Value:", val, "Currency:", currency, "AccountName:", accountName)
    def updateAccountTime(self, timeStamp: str):
        print("UpdateAccountTime. Time:", timeStamp)
    def accountDownloadEnd(self, accountName: str):
        print("AccountDownloadEnd. Account:", accountName)
    def start(self):
        # Account number can be omitted when using reqAccountUpdates with single account structure
        self.reqAccountUpdates(True, "")
    def stop(self):
        self.reqAccountUpdates(False, "")
        self.done = True
        self.disconnect()
def main():
    app = TestApp()
    app.connect("127.0.0.1", 7497, 0)
    Timer(5, app.stop).start()
    app.run()
if __name__ == "__main__":
    main()

TWS Python API Market Parameters and Scanners:
Welcome. In this lesson, we will be discussing how to request market scanner parameters, and how to request the market scanner itself.

To begin, we will need to understand which parameters we want to request. This is not technically required, though it would be suggested to be sent before your first ever request. This list is also updated periodically, so you may also wish to make a new call for this list to review it from time to time.

Access Market Scanner Parameters
For this initial program, I will use my simple TestApp class, and in my nextValidId method, I will make a simple call to self.reqScannerParameters(). Next, I can define my scannerParameters method, and I will only receive self and xml therein.

Within my scannerParameters function, I will use some file manipulation to save these details, instead of our usual print. I will save my XML file to my python samples directory, TWS API}samplesPythonTestbed.

I will set that directory to a variable string labelled dir. Then I can type open(dir,’w’).write(xml) to write my whole xml string to that file. Then I can create a quick print statement to say, “Scanner Parameters Received.”

Then I can end my file with my standard app, connect, and run combination I have used in some of our other videos.

I would like to stress that I am saving these details to a file instead of my usual print structure because there is a massive amount of data returned here. And at least in my case, my terminal cannot print all of this data. As a point of reference, this xml file is approximately 2 megabytes.

Now if we run this, we will find the file saved in our Testbed directory. I can open this file up with Visual Studio Code and see all the values present. This list is quite large, so we would encourage you to explore this to find exactly what you are looking for.

If I scroll down a bit, we can see STK.NASDAQ for example, or STK.BATS.

In addition to being able to refine my search for specific value requirements, we can use these location codes to specify the exchanges we would like to operate with. This isn’t unique for just US exchanges.

We can refine this for any country. If I search the document, I will be able to see we have scanners for Hong Kong, Korea, Belgium and more.

Moving in towards the actual filters made available to us, we can see further refinement still. We are able to see values for Volume, or perhaps going through usdVolume so we may see the total value as opposed to share quantity.

I can search nearly any tag from the Trader Workstation, and those values should be made available here. We can search for priceAbove or a variety of 52 Week calculations for stocks, options, and so on.

With the scanner parameters in place, we are set to request the market scanner.  I will be using the same values here that I was using before, with my class, nextValidId. I will once again be import TagValue using “from ibapi.tag_value import *”.

With my basic outline created, I can start building my scanner. I want to receive top stock info for the US. I will start by setting sub to ScannerSubscription() to sub as a variable. Then I will set sub.instrument = “STK”, which uses the “Instruments” tag in the XML file. Per my scanner parameters document, I can include sub.locationCode = “STK.US.MAJOR” from the locationCode tag.  This will give me all major exchanges in the US, including NYSE, Nasdaq, Amex and more.

I will use the scan code “TOP_OPEN_PERC_GAIN” which is based on the scanCode tag in that scanner parameters document.

I will now create a quick variable labelled scan_options as an empty list. And now I can create another list for filter_options. In the filter options list, I will add a few filters I want to specify for my request.

First, I will add TagValue(“volumeAbove”, “10000”) so I can receive only stocks with a volume over 10000.

Then I can add something like TagValue(“marketCapBelow”, “1000”). This would further refine my list to contracts with a lower market cap still.

And finally, I will set TagValue(“priceAbove”, “1’). This will filter out penny stocks, or anything below 1 USD.

All of these values are listed as a filter option within our scanner parameters xml file we downloaded before.

There is no limit to how much or little refinement you can choose to include here, so feel free to experiment. With that said, not every inquiry will result in a response however, as logic will still apply in this scenario.

For example, if I make a call for “Curr Year Earnings Per Share Above” I can set any earnings threshold I like. If I enter a value of 100, while my program will certainly let me make the request, but I must also understand that a company will not make $100 per share for themselves. And so, I can balance my values to return something more realistic like $10.

With that said, let’s go ahead and create our market scanner request. This requires our self.reqScannerSubscription request, and we will include a request ID, our sub variable for our Scanner Subscription object. Then we can add our scan_options list, and then our filter_options list.

We can quickly mov through our EWrapper object.

As you might expect, this is simply def scannerData. This includes variables for self, reqId, and then the contracts rank, contract details, and then distance, benchmark, projection, and legsStr. And then, as usual, I will print out all of these values. Our variables after contractDetails are values which may or may not return depending on your scanner request. You will not always receive legsStr for example, as you may not receive values for combos in your requests.

Now, moving on, we have our scannerDataEnd method, that simply includes self and the request ID. Typically I note that this is an optional field, though that is not necessary the case for scanner subscriptions. If the subscription is not closed, then you will receive an error regarding a duplicate scanner id on future requests.. And so, I will add in here a quick print that we are at the scanner data end. Then I can add self.cancelScannerSubscription and only include the request ID. After my cancellation, in my case I will make my typical call to self.disconnect().

If I run our code. I can see my usual error codes returned. Now I can also see each rank in my request, starting from rank 0 all the way to rank 49. This will only provide data with respect to the position and contract information.

This is a very basic list to get you started. Keep in mind that you can use market scanners with any other security, like options or futures, but you will need to be sure your Tag Values match up accordingly.

In a future video, we will dive into these issues more in depth to see how we can request market data from the market scanner. This concludes our video on Market Scanners in the TWS API. Thank you for watching, and we look forward to having you join us for more TWS Python API lessons.

Market Scanners – API User Guide & Examples

Scanner Parameters
from ibapi.client import *
from ibapi.wrapper import *
port = 7497
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: int):
        self.reqScannerParameters()
    def scannerParameters(self, xml):
        dir = "C:\\IBKR\\TWS API\\samples\\Python\\Testbed\\Traders Academy\\scanner.xml"
        open(dir, 'w').write(xml)
        print("Scanner parameters received!")
app = TestApp()
app.connect("127.0.0.1", port, 1001)
app.run()
Scanner Subscription
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.tag_value import *
port = 7497
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: int):
        sub = ScannerSubscription()
        sub.instrument = "STK"
        sub.locationCode = "STK.US.MAJOR"
        sub.scanCode = "TOP_OPEN_PERC_GAIN"
        scan_options = []
        filter_options = [
            TagValue("volumeAbove","10000"),
            TagValue("marketCapBelow1e6", "1000"),
            TagValue("priceAbove", '1')
        ]
        self.reqScannerSubscription(orderId, sub, scan_options, filter_options)
    def scannerData(self, reqId, rank, contractDetails, distance, benchmark, projection, legsStr):
        print(f"scannerData. reqId: {reqId}, rank: {rank}, contractDetails: {contractDetails}, distance: {distance}, benchmark: {benchmark}, projection: {projection}, legsStr: {legsStr}.")
    def scannerDataEnd(self, reqId):
        print("ScannerDataEnd!")
        self.cancelScannerSubscription(reqId)
        self.disconnect()
app = TestApp()
app.connect("127.0.0.1", port, 1001)
app.run()

TWS Python API Concurrency Example:
Hello, and welcome to this lesson on how to utilize concurrency in the TWS API. We will be discussing how to utilize multiple, concurrent requests in the API to create a rudimentary trading system. Please be aware that this program will be referencing nearly all of the prior lessons discussed in this course and will assume that the underlying behavior of these functions is already understood. This lesson focuses on utilizing these individual pieces together, for a more cohesive system. Therefore, we have already resolved the code beforehand, and instead we can step through each piece instead of our typical format.

It is extremely important for users to operate this script exclusively in a Paper Trading environment. This is not meant as trading advice and is intended for learning purposes only.

As a general statement on the matter, concurrency is the process of handling one or more calculations or operations simultaneously. This would allow us to do something like calculate our account values while retrieving continuous market data and placing trades in the background with simultaneous execution monitoring. 

We’ll start our script with the same standard build we have used throughout our tutorial series. After establishing our imports, I will create two dictionaries to use throughout our program, which are bank and position_ref. We will leave these for now and jump down to after we’ve called our run loop.

I will make a call to reqAccountUpdates, with the “subscribe” parameter set to True, so we can maintain a constant feed of our account data. Our updateAccountValue field will be very limited in scope in this implementation. I am going to exclusively filter out the “TotalCashBalance” key in use with the “BASE” currency value. Since I am only planning to trade in my base currency of USD, I don’t care to review my other values. If your base currency is something else, such as CAD, then you may want to specify “USD” here instead. Within our if statement, I will create another if statement that will disconnect my application if the val value goes below $1 Million USD. This isn’t technically necessary, though this is a very simple failsafe to make sure my code doesn’t run my account into the ground.

Next, I can put a request to app.reqPositions() after our reqAccountUpdates call. We had touched on this in our previous lesson, but this function will return data through EWrapper.position, and take arguments for self, account, contract, position, and avgCost. This will return ongoing position updates for our entirely portfolio, so we can keep track of our account as we trade. Within the EWrapper function, I will include the contract.symbol value as a key, and set it equal to the position value. That way, I know a symbol, like AAPL, will carry a certain position value throughout the day. I will be implementing this later to make sure that my account does not trigger any short position.

Moving along, we can start moving into our symbol discovery. I am going to utilize a market scanner to decide the trending contracts of the day; however, this stage could also utilize an array of pre-defined contracts instead. For my ScannerSubscription object, I will mirror my prior lesson by focusing on major U.S. stock exchanges. This time though, I will utilize the “MOST_ACTIVE” scanCode, so I can monitor the major companies like NVDA, AAPL, or TSLA. I will also only filter the exchanges with average volume above 1000000 and a price above $10 so I can filter out relatively small companies. Then, I can send out a request for our market scanner.

For the EWrapper method, I will actually filter the results with an if statements to only those with a rank value under 5. That way, we can just trade the top 5 stocks on any given day. Within our statement, I’ll first define a new value rankId, which is just the sum of our reqId and rank and have an easy integer to track our market data. Then, we’ll set our rankId to our bank dictionary, and have it reference the contract object. This way, we can equate our market data with our symbol with ease. Now let’s set the contract symbol in our position_ref dictionary to 0. This is to instantiate a position value to further prevent any short position. All of this data can go out now and create a live market data request. I won’t be using it this time, though you are welcome to declare delayed market data if necessary. Finally, I’ll print out my top-ranking contracts, so I have a frame of reference to look back on. I will also cancel my market scanner through the scannerDataEnd function this time as well; however, I will not disconnect the program.

You may have noticed that this was the first time we have printed any details throughout this script so far. The reason for this is because our program is written to work independently of me, so the printing is primarily for our tutorial and could be ignored. The same goes for all future print references, though in a production environment it would be advised to log these types of values to validate in the future.

Before diving into our next methods, let’s recap what we’ve programmed so far to largely happen simultaneously. We first requested account updates to maintain a constant check on our account balance. In my case, I’ve instructed the program to simply disconnect once I drop beneath a certain threshold. After beginning that loop, I’ve built out a request for position updates to prevent my account from shorting. Finally, I’ve created a market scanner subscription to receive the most active instruments and requested market data for them.  Even though the only concurrent requests here are to place market data subscriptions, remember that all of these requests are operating against the run() loop, which would have otherwise locked out our requests after the first had we not implemented threading.  Now we can move on to making requests happen concurrently.

With our requests for market data happening concurrently, I’m going to build out tickPrice to handle my logic. If I was concerned about things like tickSize or tickGeneric values, I could build similar logic because of my bank dictionary’s use of request ID as a tracking metric. Starting out, I will create an initial if statement to check if the “LAST” tick type is already in my bank[reqId] keys. If the value is not there, I’ll simply assign LAST to the current price. Even though the initial run will largely be skipped since the price will be the same, this will save us any errors moving forward. Afterwards, I’ll create a variable bankTick and set it to my existing LAST value. I will also create a reference to the existing contract value we set in the scanenrData function, by calling it bankContract.

After setting our variables, we can move into some order placement logic. I can create a generic order object only containing the tif, quantity, and orderType. In my case, I am only operating with Market orders, though calculating a limit price would be easy enough as well. With an order object set, I can do a quick if/else check for last price differences greater than 5% or less than 6%. These statements will determine a potential action, BUY or SELL, and then submit my affiliated order. I can submit these orders using my nextId method, my bankContract contract, and then our new order object. In addition to the percentage calculation for my SELL logic, I am also going to check if the contract’s position is at least 5, so I don’t short. And to cap off my function, I’ll set my contract’s LAST price to my current price, to reference in the next iteration of comparison.

Now, for additional tracking metrics, I can create a reference to openOrder and execDetails. In my case, I will format them as an easy-to-read format so I can glance at the execution behavior. I am just printing rejected orders from my openOrders response, though it would stand to print all details for something like a LMT order, which may not be expected to execute immediately. As mentioned before, this is technically an optional step as it is solely used for viewing purposes. Users may look to log things like execution prices and order details for end of day review.

Though to recap our order behavior since our last, we are now acknowledging the 5 concurrent market data requests, and on each tick we are calculating whether or not an order should be triggered or not based on our very simple logic. Once the market data fits our criteria, we launch out an order, where we can find updates later in the openOrder or execDetails methods. We are now completely done with this script, and with any luck, we can earn some simulated dollars.

In a relatively short span of time, we were able to construct an entirely automated system to trade throughout the day. There is plenty of room for improvement, and flexibility from other lessons, but this is an excellent scenario to gain some confidence in making concurrent requests and handling multiple actions simultaneously.

Users interested in learning more should look to implement defensive trading logic, such as trading bracket orders rather than our simple Market orders that were discussed in the Complex Order lesson. Alternatively, you may want to create logic around historical trends of our scanned contracts, rather than plucking the top 5 to ensure safer trading. 

This concludes our lesson on utilizing concurrency in the TWS API. Thank you for watching. If you have any questions, please be sure to review our documentation or leave a comment below this video. Thank you for following along throughout the series.

Code Snippet – concurrency.py
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.tag_value import TagValue
import datetime
import time
import threading
port = 7497
bank = {}
position_ref = {}
class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)
    def nextValidId(self, orderId: OrderId):
        self.orderId = orderId
    
    def nextId(self):
        self.orderId += 1
        return self.orderId
    
    def error(self, reqId, errorCode, errorString, advancedOrderReject):
        print(f"reqId: {reqId}, errorCode: {errorCode}, errorString: {errorString}, orderReject: {advancedOrderReject}")
    def updateAccountValue(self, key, val, currency, accountName):
        if key == "TotalCashBalance" and currency == "BASE":
          bank[key] = float(val)
          # If we drop below $1M, disconnect
          if float(val) <1000000:
              self.disconnect()
    
    def position(self, account, contract, position, avgCost):
        position_ref[contract.symbol] = position
    def scannerData(self, reqId, rank, contractDetails, distance, benchmark, projection, legsStr):
        if rank < 5:
            rankId = rank+reqId
            bank[rankId] = {"contract": contractDetails.contract}
            position_ref[contractDetails.contract.symbol] = 0
            app.reqMktData(rankId, contractDetails.contract, "", False, False, [])
            print(f"Rank {rank} Contract: {contractDetails.contract.symbol} @ {contractDetails.contract.exchange}")
    def scannerDataEnd(self, reqId):
        self.cancelScannerSubscription(reqId)
      
    def tickPrice(self, reqId, tickType, price, attrib):
        if "LAST" not in bank[reqId].keys():
            bank[reqId]["LAST"] = price
        bankTick = bank[reqId]["LAST"]
        bankContract = bank[reqId]["contract"]
        order = Order()
        order.tif = "DAY"
        order.totalQuantity = 5
        order.orderType = "MKT"
        # If the new price is more than 5% higher than our previous price point.
        if (bankTick * 1.05) < price:
            order.action = "BUY"
            app.placeOrder(app.nextId(), bankContract, order)
        # If the new price is less than 6% of our previous price point
        elif (bankTick * 0.94) > price and position_ref[bankContract.symbol] >= 5:
            order.action = "SELL"
            app.placeOrder(app.nextId(), bankContract, order)
        bank[reqId]["LAST"] = price
    
    def openOrder(self, orderId, contract, order, orderState):
        if orderState.status == "Rejected":
            print(f"{datetime.datetime.now()} {orderState.status}: ID:{orderId} || {order.action} {order.totalQuantity} {contract.symbol}")
    
    def execDetails(self, reqId, contract, execution):
        print(f"Execution Details: ID:{execution.orderId} || {execution.side} {execution.shares} {contract.symbol} @ {execution.time}")
app = TestApp()
app.connect("localhost", port, 1005)
threading.Thread(target=app.run).start()
time.sleep(1)
app.reqAccountUpdates(True, "")
app.reqPositions()
sub = ScannerSubscription()
sub.instrument = "STK"
sub.locationCode = "STK.US.MAJOR"
sub.scanCode = "MOST_ACTIVE"
scan_options = []
filter_options = [
    TagValue("avgVolumeAbove","1000000"),
    TagValue("priceAbove", '10')
]
app.reqScannerSubscription(app.nextId(), sub, scan_options, filter_options)